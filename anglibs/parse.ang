[`io,`regex] each {i library drop}
package parse

private

0!StaticSymbolCount
:gensymbol
    "PSM" ?StaticSymbolCount + tosymbol
    ?StaticSymbolCount 1+ !StaticSymbolCount
;
gensymbol !Missing


public


# Parsers - these take the remaining tokens, and either consume an item
# or not. They return a hash containing `toks, the new token list;
# and `item, which is none if the parser did not match. Otherwise
# it contains the parser resultst. The new token
# list will have all relevant items consumed if a match happened.
# To summarise, successful parser output is 
#    [% `item X, `toks list]
# and failed parser output is
#    [% `item none, `toks list]

:parser |f/closure,label/symbol:|
    (|toks:tnew,t|
        # put a copy of the tokens into the parsing func and get
        # the output
        ?toks clone !tnew
        ?tnew ?f@ !t
        [% `toks ?t isnone if ?toks else ?tnew then, 
         `item ?t]
    )
;

# generate a parser which matches an input token on a given condition

:matchparser |cond:|
    (|toks:t|
        ?toks len 0 = if none stop then
        ?toks shift !t
        ?t ?cond@ if
            ?t
        else 
            none then
    )
    `match parser;

# useful debugging routine for dumping parser output

:id |h/hash:tabs|
    0!tabs
    ?h?`item
    (|item:|
        0 ?tabs range each {" "p}
        ?item isnone if
            "ERROR". 
        else
            ?item type `list = if
                nl
                ?tabs 1+ !tabs
                ?item each {i recurse}
                ?tabs 1- !tabs
            else
                ?item .
            then
        then
    ) @
;

# takes a list of the form 
#   [ [% k1 v1], [% k2,v2]... ]
# and generates
#   [ v1,v2,...]
# Used to process lists of single item hashes generated by dehash.
# Will recursively dehash any lists found as item values.

:dehashlist |l/list:t|
    [] ?l each {
        i dup mkiter dup ifirst icur swap get !t
        ?t type `list = if
            ?t dehashlist
        else
            ?t
        then,
    }
;


# takes a list of the form 
#   [ [% k1 v1], [% k2,v2]... ]
# and generates
#   [% k1 v1, k2 v2,...]
# Used to process lists of single item hashes generated by dehash.
# Will recursively dehash any lists found as item values.
# KEYS MUST BE UNIQUE or stuff will get lost.

:dehashlisttohash |l/list:k,v,iter|
    [%] ?l each {
        i mkiter !iter
        ?iter ifirst
        ?iter icur !k
        ?k i get !v
        
        ?k
        ?v type `list = if
            ?v dehashlisttohash !v
        else
            ?v
        then,
    }
;
    
    
    
                        
            

# parser generator for choices - this returns a parser which
# will attempt to use one of a list of parsers.

:choice |lst/list:|
    (|toks:t|
        ?lst each {
            ?toks i @ !t
            ?t?`item isnone not if ?t stop then
        } [% `item none, `toks ?toks]
);

# parser generator for sequences - this returns a parser which will
# use a list of parsers in sequence. If it worked, the `item field
# in the result will be a list of the tokens successfully parsed.

:seq |lst/list:|
    (|toks:t,alltoks,res|
        []!res
        ?toks clone !alltoks
        ?lst each {
            ?toks i @ !t
            ?t?`item isnone if
                [% `item none, `toks ?alltoks] stop
            then
            ?t?`item ?Missing != if
                ?t?`item ?res push 
            then
            ?t?`toks !toks
        }
        [% `item ?res, `toks ?toks]
    )
;

:sepby |parser/closure,sep/closure:|
    (|toks:t,alltoks,res|
        []!res
        # consume first item
        ?toks ?parser @ !t
        ?t?`item isnone if
            [% `item none, `toks ?alltoks] stop
        then
        ?t?`item ?Missing != if
            ?t?`item ?res push 
        then
        ?t?`toks !toks
        {
            # attempt to consume separator
            ?toks ?sep @ !t
            ?t?`item isnone ifleave
            ?t?`toks !toks
            # attempt to consume value, fatal if can't
            ?toks ?parser @ !t
            ?t?`item isnone if
                [% `item none, `toks ?alltoks] stop
            then
            ?t?`item ?Missing != if
                ?t?`item ?res push 
            then
            ?t?`toks !toks
        }
        [% `item ?res, `toks ?toks]
    )
;



#
# Parse an optional item - will return a `missing item if the
# item was not present, which will be filtered out sequencing
# parsers (like seq and many).

:maybe |parser:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone if
            [% `item ?Missing, `toks ?toks]
        else
            ?t
        then
    )
;
        
# makes the parser throw away the item it has successfully
# parsed by returning item `missing, which will be filtered
# out by sequencing parsers.

:skip |parser:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone if
            ?t
        else
            [% `item ?Missing, `toks ?t?`toks]
        then
    )
;


# generate a parser which takes another parser, and which runs
# an action on the parser's result if it is successful.


:action |parser/closure,action:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone not if
            ?t?`item ?action@ 
        then
        ?t
    )
;


# perform some debugging action on a parser (like action,
# but takes the entire parser output as its argument)
:deb |parser/closure,f:|
    (
        ?parser @ dup ?f@
    )
;

# one or more items, making a list of the items. If none found,
# `items is none. If some found, `items is a list of the items.

:many |parser/closure:|
    (|toks:t,items|
        []!items
        {
            ?toks ?parser @ !t
            ?t?`item isnone ifleave
            ?t?`item ?Missing != if
                ?t?`item ?items push
            then
            ?t?`toks !toks
        }
        [% `item ?items len if ?items else none then,
         `toks ?toks]
    )
;

# create a parser which takes the results of the given parser
# (assumed to be a list result, like seq or many) and makes
# the result of element N the result, rather than the whole
# list.

:return |parser/closure,n:|
    (|toks:t,r|
        ?toks ?parser @ !t
        ?t?`item isnone not if
            ?n ?t?`item get ?t!`item
        then
        ?t
    )
;

    

# generate a parser which modifies the item produced by another
# parser (if it did produce one). The function provided takes
# and item and returns something to replace it with.

:moditem |parser/closure,action:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone not if
            ?t?`item ?action@ ?t!`item
        then
        ?t
    )
;

# parser which filters the results of a sequential parser

:filterparser |p/closure,f:|
    (|toks:t|
        ?toks ?p @ !t
        ?t?`item isnone not if
            ?t?`item type `list = if
                ?t?`item (?f@) 
                filter ?t!`item
            then
        then
        ?t
    )
;

# generate an error action parser - this takes a parser, and if
# the parser does not match, fails fatally with a message. Don't
# use this if you are relying on the parser to terminate a sequence
# when an parser fails.    

:error |parser/closure,error:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone if
            ?error. 
            " at: "p ?toks 0 10 slice "," intercalate.
            quit
        then
        ?t
    )
;

# somewhat hacky code for running a known sequence of parsers,
# intercalated with another parser. Generates a new sequence
# of parsers intercalated with the separator parser with a special label,
# then filters those out.

:seqsepby |lst/list,sep/closure:s|
    gensymbol!s
    ?lst ?sep (drop ?s) listintercalate seq
    (?s !=) filterparser
;



# this parser catches anything, and is used as the last part of
# a choice. It takes an action and consumes all remaining input,
# but returns a null item.

:anything |action:|
    (|toks:|
        ?action@
        [%`item none, `toks []]
    )
;
        
# parser generator for strings - this returns a function which
# will parse this string (or not, if it wasn't there)
    
:strparser |s/string:|
    (|toks:t|
        ?toks len 0 = if none stop then
        ?toks shift ?s = if ?s else none then) `string parser
;
    
# create a parser for parsing regexes
:regexparser |s/string:r|
    ?s regex$compile !r
    (|toks:t|
        ?toks len 0 = if none stop then
        ?toks shift dup !t ?r regex$match len 1 = if
            ?t else none then) `regex parser
;
    
# parse the end of data, giving `end as the item
(|toks:t|
    [% `item 
      ?toks len 0 = if `end else none then,
     `toks ?toks ]
) !EndOfData

######### character parsing stuff (if we're tokenising too) ##########

# convert a string to a list of characters

:strtolist |s:| [] ?s each {i,};

# generate a character parser

:charparser |c:| (?c = )matchparser;

# generate a parser which takes the result of a sequence parser
# and concatenates them all together - often used to generate
# strings from sequences of character parsers.

:concatcons |parser/closure:|
    ?parser (|c:|"" ?c  each {i+}) moditem;

