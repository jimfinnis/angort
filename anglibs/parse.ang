[`io,`regex] each {i library drop}
package parse


# Parsers - these take the remaining tokens, and either consume an item
# or not. They return a hash containing `toks, the new token list;
# and `item, which is none if the parser did not match. Otherwise
# it is a hash of `label and `content. The new token
# list will have all relevant items consumed if a match happened.
# To summarise, successful parser output is 
#    [% `item [% `label foo, `content bar], `toks list]
# and failed parser output is
#    [% `item none, `toks list]

:parser |f/closure,label/symbol:|
    (|toks:tnew,t|
        # put a copy of the tokens into the parsing func and get
        # the output
        ?toks clone !tnew
        ?tnew ?f@ !t
        ?t isnone if
            [%`toks ?toks, `item none]
        else
            [%`toks ?tnew, `item [% `label ?label, `content ?t] ]
        then
    )
;

# generate a parser which matches an input token on a given condition

:matchparser |cond:|
    (|toks:t|
        ?toks len 0 = if none stop then
        ?toks shift !t
        ?t ?cond@ if
            ?t
        else 
            none then
    )
    `match parser;

# useful debugging routine for dumping parser output

:id |h/hash:tabs|
    0!tabs
    ?h?`item
    (|item:|
        0 ?tabs range each {" "p}
        ?item isnone if
            "ERROR". 
        else
            ?item?`label isnone if "??" else ?item?`label then p
            " : " p
            ?item?`content type `list = if
                nl
                ?tabs 1+ !tabs
                ?item?`content each {i recurse}
                ?tabs 1- !tabs
            else
                ?item?`content .
            then
        then
    ) @
;

0!StaticSymbolCount
:gensymbol
    "GEN" ?StaticSymbolCount + tosymbol
    ?StaticSymbolCount 1+ !StaticSymbolCount
;

# takes a content block and converts it to a simpler hash.
# Used by dehash, but also in actions as 
#  (|lst:| ?lst?`content condehash..)
# Often followed by dehashlist on list items
:condehash |i:|
    cases
        ?i type `list = if
            ?i (condehash) map
        case
        ?i type `hash = if
            [% ?i?`label isnone if gensymbol else ?i?`label then
             ?i?`content condehash]
        case
        ?i otherwise
;

# dehashes the content block of an item, converting it
# to a simpler hash
:itemdehash |t/hash:|
    ?t?`content condehash;
    
    
# takes a result set and converts it to a simpler hash
# Often followed by dehashlist on list items
:dehash |t/hash:|
    ?t?`item isnone if
        "Cannot dehash a failed parse". quit
    then
    ?t?`item?`content condehash;

# takes a list of the form 
#   [ [% k1 v1], [% k2,v2]... ]
# and generates
#   [ v1,v2,...]
# Used to process lists of single item hashes generated by dehash.
# Will recursively dehash any lists found as item values.

:dehashlist |l/list:t|
    [] ?l each {
        i dup mkiter dup ifirst icur swap get !t
        ?t type `list = if
            ?t dehashlist
        else
            ?t
        then,
    }
;


# takes a list of the form 
#   [ [% k1 v1], [% k2,v2]... ]
# and generates
#   [% k1 v1, k2 v2,...]
# Used to process lists of single item hashes generated by dehash.
# Will recursively dehash any lists found as item values.
# KEYS MUST BE UNIQUE or stuff will get lost.

:dehashlisttohash |l/list:k,v,iter|
    [%] ?l each {
        i mkiter !iter
        ?iter ifirst
        ?iter icur !k
        ?k i get !v
        
        ?k
        ?v type `list = if
            ?v dehashlisttohash !v
        else
            ?v
        then,
    }
;
    
    
    
                        
            

# parser generator for choices - this returns a parser which
# will attempt to use one of a list of parsers.

:choice |lst/list:|
    (|toks:t|
        ?lst each {
            ?toks i @ !t
            ?t?`item isnone not if ?t stop then
        } [% `item none, `toks ?toks]
);

# parser generator for sequences - this returns a parser which will
# use a list of parsers in sequence. If it worked, the `item field
# in the result will be a list of the tokens successfully parsed.

:seq |lst/list:|
    (|toks:t,alltoks,res|
        []!res
        ?toks clone !alltoks
        ?lst each {
            ?toks i @ !t
            ?t?`item isnone if
                [% `item none, `toks ?alltoks] stop
            then
            ?t?`item `missing != if
                ?t?`item ?res push 
            then
            ?t?`toks !toks
        }
        [% `item [% `content ?res, `label `seq], `toks ?toks]
    )
;

:sepby |parser/closure,sep/closure:|
    (|toks:t,alltoks,res|
        []!res
        # consume first item
        ?toks ?parser @ !t
        ?t?`item isnone if
            [% `item none, `toks ?alltoks] stop
        then
        ?t?`item `missing != if
            ?t?`item ?res push 
        then
        ?t?`toks !toks
        {
            # attempt to consume separator
            ?toks ?sep @ !t
            ?t?`item isnone ifleave
            ?t?`toks !toks
            # attempt to consume value, fatal if can't
            ?toks ?parser @ !t
            ?t?`item isnone if
                [% `item none, `toks ?alltoks] stop
            then
            ?t?`item `missing != if
                ?t?`item ?res push 
            then
            ?t?`toks !toks
        }
        [% `item [% `content ?res, `label `sepby], `toks ?toks]
    )
;



#
# Parse an optional item - will return a `missing item if the
# item was not present, which will be filtered out sequencing
# parsers (like seq and many).

:maybe |parser:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone if
            [% `item `missing, `toks ?toks]
        else
            ?t
        then
    )
;
        
# makes the parser throw away the item it has successfully
# parsed by returning item `missing, which will be filtered
# out by sequencing parsers.

:skip |parser:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone if
            ?t
        else
            [% `item `missing, `toks ?t?`toks]
        then
    )
;


# generate a parser which takes another parser, and which runs
# an action on the parser's result if it is successful. The result
# is an item, and it's often useful to do something like
#   (|t:| ?t itemdehash ...)
# or
#   (|t:| ?t?`itemdehash dehashlist...) [for sequences]
# on this item, for ease of handling.


:action |parser/closure,action:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone not if
            ?t?`item ?action@ 
        then
        ?t
    )
;


# perform some debugging action on a parser (like action,
# but takes the entire parser output as its argument)
:deb |parser/closure,f:|
    (
        ?parser @ dup ?f@
    )
;

# add a label tag to the output, if non-null and not missing
:label |parser/closure,s:|
    ?parser (|item:| 
        ?item type `hash = if
            ?s `label ?item set
    then) action;


# one or more items, making a list of the items. If none found,
# `items is none. If some found, `items is a list of the items.

:many |parser/closure:|
    (|toks:t,items|
        []!items
        {
            ?toks ?parser @ !t
            ?t?`item isnone ifleave
            ?t?`item `missing != if
                ?t?`item ?items push
            then
            ?t?`toks !toks
        }
        [% `item ?items len if [% `content ?items] else none then,
         `toks ?toks]
    )
;

# create a parser which takes the results of the given parser
# (assumed to be a list result, like seq or many) and makes
# the result of element N the result, rather than the whole
# list.

:return |parser/closure,n:|
    (|toks:t,r|
        ?toks ?parser @ !t
        ?t?`item isnone not if
            ?n ?t?`item?`content get ?t!`item
        then
        ?t
    )
;

    
# like return, but searches for a labelled item within the content
# (again assumed to be a list)

:retlab |parser/closure,l:|
    "UNTESTED".
    (|toks:t,r|
        ?toks ?parser @ !t
        `missing !r
        ?t?`item isnone not if
            ?t?`item?`content each {
                i?`label ?l = if
                    i !r leave
                then
            }
            ?r ?t!`item
        then
        ?t
    )
;

# generate a parser which modifies the item produced by another
# parser (if it did produce one). The function provided takes
# and item and returns something to replace it with.

:moditem |parser/closure,action:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone not if
            ?t?`item?`content ?action@ ?t?`item!`content
        then
        ?t
    )
;

# parser which filters the results of a sequential parser by label

:filterparser |p/closure,f:|
    (|toks:t|
        ?toks ?p @ !t
        ?t?`item isnone not if
            ?t?`item?`content type `list = if
                ?t?`item?`content (?`label ?f@) 
                filter ?t?`item!`content
            then
        then
        ?t
    )
;

# generate an error action parser - this takes a parser, and if
# the parser does not match, fails fatally with a message. Don't
# use this if you are relying on the parser to terminate a sequence
# when an parser fails.    

:error |parser/closure,error:|
    (|toks:t|
        ?toks ?parser @ !t
        ?t?`item isnone if
            ?error. 
            " at: "p 0 10 ?toks slice "," intercalate.
            quit
        then
        ?t
    )
;

# somewhat hacky code for running a known sequence of parsers,
# intercalated with another parser. Generates a new sequence
# of parsers intercalated with the separator parser with a special label,
# then filters those out.

:seqsepby |lst/list,sep/closure:s|
    gensymbol!s
    ?lst ?sep ?s label listintercalate seq
    (?s !=) filterparser
;



# this parser catches anything, and is used as the last part of
# a choice. It takes an action and consumes all remaining input,
# but returns a null item.

:anything |action:|
    (|toks:|
        ?action@
        [%`item none, `toks []]
    )
;
        
# parser generator for strings - this returns a function which
# will parse this string (or not, if it wasn't there)
    
:strparser |s/string:|
    (|toks:t|
        ?toks len 0 = if none stop then
        ?toks shift ?s = if ?s else none then) `string parser
;
    
# create a parser for parsing regexes
:regexparser |s/string:r|
    ?s regex$compile !r
    (|toks:t|
        ?toks len 0 = if none stop then
        ?toks shift dup !t ?r regex$match len 1 = if
            ?t else none then) `regex parser
;
    
# parse the end of data, giving `end as the item
(|toks:t|
    [% `item 
      ?toks len 0 = if [% `label `end, `content `end] else none then,
     `toks ?toks ]
) !EndOfData

######### character parsing stuff (if we're tokenising too) ##########

# convert a string to a list of characters

:strtolist |s:| [] ?s each {i,};

# generate a character parser

:charparser |c:| (?c = )matchparser;

# generate a parser which takes the result of a sequence parser
# and concatenates them all together - often used to generate
# strings from sequences of character parsers.

:concatcons |parser/closure:|
    ?parser (|c:|"" ?c condehash dehashlist each {i+}) moditem;

