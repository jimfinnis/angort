Not yet documented:
    barewords
    recurse
    def defconst

There should be an Angort namespace.

Need to show func names in debugging

multiple requires/library loads need to work


Given that there are quite a few singletons (e.g type objects)
there's no real point in Angort not being a singleton.

Closures:
    There's a better way of doing closures. Instead of each ")" operation
    creating a closure in the child which refers to the parent, we
    create a closure as soon as the first ?xx is created. This belongs
    to the outer (creating) context, and references to it are given
    to any children, with new entries in the closure table being
    created as necessary. All subsequent references to closed variables
    in the outer function are then references to the closure.
    
    In upshot, then, there is only one closure created, and it belongs
    to both the children and the outer function.

How namespaces now work:
    When a namespace is imported, it is both added to the import list
    and all entries which are not private are marked as imported.
    The space itself is marked as imported, so that new entries made
    after the import are also marked as imported. This only applies
    when the entire space is imported - partial imports just mark the
    imported items, not the whole space.

    Two namespaces are created at startup: std and user.
    All standard words are added to std, notwithstanding their
    "module" name which is currently ignored. The user namespace
    is then left as the current namespace into which words are defined.
    Both these namespaces are fully imported.

    When searching for a name, fully specified names are resolved by
    searching only the given space (including privates.) Otherwise,
    the current space is searched, followed by the entries marked as
    imported in the imported spaces.
    
    An exception to this is when the "global" directive is used to define
    a new global - in this case, the imported spaces are not searched.

    Consider the following situation: you want to create a new definition
    for a standard word, say "p". If you write:
    
        :p .. ;
    
    the error "cannot redefine constant p" will result - this is 
    because the system finds std$p and thinks you want to write over
    it. However, if you do
    
        global p
        :p ... ;
        
    that will work, because the "global" will create a new definition
    in the user namespace (because it doesn't search the imported namespaces).
    The word definition will find this new value first, and will
    write the word codeblock to it. The std$p word will still be
    available by using its full name.
          
    
