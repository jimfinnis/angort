Leaving an iterator loop early leaves GC stuff, because the iterator stack is
not popped:
    range 1 10 1 each {i 5> ifleave i.}
Solution - push NULL onto the iterator stack when we enter a non-iterator loop,
and when we leave, pop that stack and clear the value if it's not null.

Code and word specs


Closures have a problem:
    :foo |:x| 4!x (?x 1+ !x)@ ?x .;
    foo
prints "4" and not "5", because the lambda modifies its closure's copy
and not the original. This is usually the right thing to do, of course.



