#
# list tests, need expanding
#

[1,2,3] pop 3= "pop item" assert

[1,2,3,4,5] (2 % 0 =) filter !L
?L len 2 = "filter1" assert
?L pop 4 = "filter2" assert
?L pop 2 = "filter3" assert

[1,2,3,4,5] (2 % 0 =) filter !L

2 ?L in "listin1" assert
4 ?L in "listin2" assert
1 ?L in not "listin2" assert
3.0 ?L in not "listin3" assert
10 ?L in not "listin4" assert

# slices

:eq |x,y:| # quick list equiv check
    ?x type "list"=
    ?y type "list"= and
    ?x len ?y len = and
    not if 0 stop then
    0 ?x len range each {
        i ?x get i ?y get =
        not if 0 stop then
    }
    1
;

"fish" [1,2,3,4,5] eq not "listeq0" assert
"fish" [1,2,3,4,5] swap eq not "listeq01" assert

[1,2,3,4,5] [1,2,3,4,5] eq "listeq1" assert
[1,2,2,4,5] [1,2,3,4,5] eq not "listeq2" assert

[1,2,3] [1,2] eq not "listeq3" assert

[1,2,3,4,5] !L
0 3 ?L slice [1,2,3] eq "lslice1" assert
0 3 ?L slice [1,2,3] eq "lslice2" assert
1 3 ?L slice [2,3,4] eq "lslice3" assert
2 3 ?L slice [3,4,5] eq "lslice4" assert
3 3 ?L slice [4,5] eq "lslice5" assert
4 3 ?L slice [5] eq "lslice6" assert
2 -1 ?L slice [3,4,5] eq "lslice7" assert
5 0 ?L slice [] eq "lslice8" assert
6 1 ?L slice [] eq "lslice9" assert
7 1 ?L slice [] eq "lslice10" assert
-1 3 ?L slice [1,2,3] eq "lslice11" assert

quit
