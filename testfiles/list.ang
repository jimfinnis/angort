#
# list tests, need expanding
#

[1,2,3] pop 3= "pop item" assert

[1,2,3,4,5] (2 % 0 =) filter !L
?L len 2 = "filter1" assert
?L pop 4 = "filter2" assert
?L pop 2 = "filter3" assert

[1,2,3,4,5] (2 % 0 =) filter !L

2 ?L in "listin1" assert
4 ?L in "listin2" assert
1 ?L in not "listin2" assert
3.0 ?L in not "listin3" assert
10 ?L in not "listin4" assert

# slices
:eq |x,y:| # quick list equiv check
    ?x type "list"=
    ?y type "list"= and
    ?x len ?y len = and
    not if 0 stop then
    0 ?x len range each {
        i ?x get i ?y get =
        not if 0 stop then
    }
    1
;

"fish" [1,2,3,4,5] eq not "listeq0" assert
"fish" [1,2,3,4,5] swap eq not "listeq01" assert

[1,2,3,4,5] [1,2,3,4,5] eq "listeq1" assert
[1,2,2,4,5] [1,2,3,4,5] eq not "listeq2" assert

[1,2,3] [1,2] eq not "listeq3" assert

[1,2,3,4,5] !L
?L 0 3 slice [1,2,3] eq "lslice1" assert
?L 0 3 slice [1,2,3] eq "lslice2" assert
?L 1 3 slice [2,3,4] eq "lslice3" assert
?L 2 3 slice [3,4,5] eq "lslice4" assert
?L 3 3 slice [4,5] eq "lslice5" assert
?L 4 3 slice [5] eq "lslice6" assert
?L 2 -1 slice [3,4,5] eq "lslice7" assert
?L 5 0 slice [] eq "lslice8" assert
?L 6 1 slice [] eq "lslice9" assert
?L 7 1 slice [] eq "lslice10" assert
?L -1 3 slice [1,2,3] eq "lslice11" assert

# cloning

[1,2,3] !L
?L clone !L2
?L ?L2 eq "lclone1" assert
4 ?L2 push 
?L2 [1,2,3,4] eq "lclone2" assert
?L [1,2,3] eq "lclone2" assert

1 ?L remove 2 = "lremove" assert
[1,3] ?L eq "lremove2" assert

quit
