# takes x, makes a function which adds x to the argument y
:makeadder |x:| (|y:| ?x ?y +) ;

#stack 5, make a function to add 4, run it on 5.
5 4 makeadder @ 
9 = "closure1" assert
# 4 way string concat, the first 2 strings are stored in the closure

:test |x,y:|
    (|a,b:| ?x ?y ?a ?b + + +)
;

global t
"step 1" p nl
"foo" "bar" test !t
"step 2" p nl
"zog" "fish" ?t@ "foobarzogfish" = "closure2a" assert
"step 3" p nl
"zog1" "fish" ?t@ "foobarzog1fish" = "closure2b" assert
"step 4" p nl
"blas" "frink" ?t@ "foobarblasfrink" = "closure2c" assert
"step 5" p nl
"boz" "1" test !t
"step 6" p nl
"zig" "foo" ?t@ "boz1zigfoo" = "closure3" assert
"step 7" p nl
1 !t # overwrite 

gccount 0 = "closuregc0" assert # GC count should be zero here


# OK, nested closure. This is a function which takes two arguments,
# returning a function which takes two arguments which returns a function
# which takes two arguments. That bottom function joins all the arguments
# together.

:test2 |x,y:|
    (
        |a,b:|
        (
            |c,d:|
            ?x ?y ?a ?b ?c ?d + + + + +))
;

# produces a function which takes two args and returns a closure for a function
# which takes two args...
"foo" "bar" test2 !t

# call that function with the necessary arguments to get another one, also with
# two arguments

"biz" "boz" ?t@ !t

# now run *that* function 
"glem" "zark" ?t@

# and test the result
"foobarbizbozglemzark" = "nested closures" assert

1 !t # clear the "t" variable to drop the reference

# if you write a closure over a closure, the total gc count should not increment
0 gccount = "closure over closure gc" assert


# in this case, there was a problem when a closure which was only referred to
# on the stack was called. When the closure was called, the closure reference
# was popped and decreffed to 0. Then, when another value was placed on the stack
# *inside* the closure, the stack frame previously holding the closure was overwritten,
# causing the zero-reffed closure to delete itself. A subsequent call to OP_CLOSUREGET
# tried to read a variable from inside the now deleted closure table, giving NONE and
# a failure.
# The cure is to have a separate stack, gcrstack, on which closures are increffed and
# stacked when they are called, and popped and decreffed on OP_END.

:quop |x:| (?x +);
1 1 quop @ 2 = "closure weirdness" assert


0 !t 1 1 1 drop drop drop
# closure mutability

:mkcounter |:ct|
    0 !ct
    (?ct 1+ dup !ct)
;

global a
global b

mkcounter !a
mkcounter !b

"GCCOUNT=" p gccount p nl

?a@ 1 = "mutclosa1" assert
?a@ 2 = "mutclosa2" assert
?a@ 3 = "mutclosa3" assert
?b@ 1 = "mutclosb1" assert
?b@ 2 = "mutclosb2" assert
?b@ 3 = "mutclosb3" assert

1 1 1 1 1 1 1 1 1 # stack overwrite
0 !a
0 !b
0 !t
"GCCOUNT=" p gccount p nl
quit
