\clearpage
\section{Keywords and tokens}
The Angort language contains the following tokens -- strings and characters which are
interpreted by the parser directly. Most of
these are converted one-to-one into bytecode instructions, although a few
are syntactic markers and affixes (such as the single quote for symbols and
the vertical bar ``\verb+|+'' for delimiting the function local variable definitions).
\begin{center}
% table generated by tablify.ang, from gentoks output
\begin{tabular}{|l|l|l|l|l|}\hline
\verb+!=+ & \verb+<=+ & \verb+>=+ & \verb+?`+ & \verb+!`+\\
\verb-!+- & \verb+!-+ & \verb+<<+ & \verb+>>+ & \verb+??+\\
\verb+{+ & \verb+}+ & \verb+(+ & \verb+)+ & \verb+[+\\
\verb+]+ & \verb+,+ & \verb+<+ & \verb+>+ & \verb+=+\\
\verb-+- & \verb+/+ & \verb+-+ & \verb+*+ & \verb+;+\\
\verb+.+ & \verb+!+ & \verb+?+ & \verb+@+ & \verb+:+\\
\verb+#+ & \verb+&+ & \verb+|+ & \verb+%+ & \verb+`+\\
\verb+if+ & \verb+then+ & \verb+else+ & \verb+leave+ & \verb+dup+\\
\verb+call+ & \verb+global+ & \verb+swap+ & \verb+drop+ & \verb+not+\\
\verb+and+ & \verb+or+ & \verb+ifleave+ & \verb+const+ & \verb+over+\\
\verb+each+ & \verb+include+ & \verb+stop+ & \verb+cmp+ & \verb+package+\\
\verb+require+ & \verb+private+ & \verb+public+ & \verb+def+ & \verb+defconst+\\
\verb+recurse+ & \verb+self+ & \verb+cases+ & \verb+case+ & \verb+otherwise+\\
\verb+sourceline+ & \verb+yield+ & \verb+try+ & \verb+catch+ & \verb+catchall+\\
\verb+throw+ & \verb+inc+ & \verb+dec+ &  & \\
\hline\end{tabular}
\end{center}
Everything else is either a literal (such as \texttt{35.0} or \verb+"wibble"+),
a local variable name, or the name of a function or global variable\footnote{Functions
are actually global variables, see Sec.~\ref{globdetails}.}.
Functions and globals are identifiers bound to a value, stored in a namespace (see Sec.~\ref{namespaces}).



\section{Getting started: immediate mode}
This section will describe the basic concepts behind the language,
such as reverse Polish notation and the stack, and introduce
using the language in immediate mode.   

\subsection{Immediate mode}
In immediate mode, each line of Angort is compiled and run straight
away. It is the default mode of the Angort interpreter, even with script
files as we will see below.
Angort will be in
this mode when a script completes without \texttt{quit} 
being called.
In immediate mode, when a script has not been provided on the command
line or a script has completed without quitting, Angort shows a prompt like this:
\begin{v}
1|0 >
\end{v}
The two numbers are the number of garbage-collectable objects in the
system and the number of items on the stack, respectively.
The interpreter is in ``immediate mode'', as opposed to ``compilation
mode'' --- any text entered will be compiled to bytecode and run when
enter is pressed,
rather than being added to a function definition.

\subsection{Reverse Polish notation and the stack}
\index{stack}
Angort is a stack-based language:
there is a single stack containing
values, and most functions change the contents
of the stack in some way. For example,
\begin{v}
3
\end{v}
by itself will just put the value 3 on the stack. Then
\begin{v}
.
\end{v}
will pop the value from the top of the stack and print it.
\begin{v}
3 4 + .
\end{v}
will push 3 and 4 onto the stack, then add them together replacing them
with 7, and then print the 7. This kind of notation is often
referred to as \textbf{reverse Polish notation} (RPN) as opposed to the more common
\textbf{infix} notation. More complex expressions are built 
out of sequences of operations on the stack. For example, the expression
\[
\sin(5+32+\sqrt{43 \times 12})
\]
would be written as
\begin{v}
43 12 * sqrt 32 + 5 + sin
\end{v}
which can be read as ``multiply 43 and 12, find the square root,
add 32, add 5, find the sine.''
This is a little difficult at first, but rapidly becomes second
nature\footnote{Most old calculators work using RPN, and quite a few
of the more powerful programmables still do.}

\subsection{Running scripts}
Scripts are traditionally\footnote{A somewhat unusual word to use when
there is currently only one user of the language.} given the extension
\texttt{.ang}, but this appears nowhere in the codebase. To run a script,
create a file of Angort function definitions and commands and pass it as
an argument to the \texttt{angort} command. Angort will still run
the script in immediate mode: each line will be parsed
and run in order. If a function definition is encounted, Angort will switch
to compilation mode for the duration of the function.

Again, in immediate mode (i.e. outside a function) each line of Angort
is parsed and run
immediately. This means that multiline flow control constructs (such as loops
and \texttt{if..then}) will not work unless they are inside a function.
This is easily solved by using anonymous functions, as described in Section~\ref{multilineflow}.

At the end of a script, Angort will be in immediate mode and will ask for
more lines, with
the prompt described above. This is often useful
when Angort is used to provide a domain-specific control language: the script sets up
a large number of commands and perhaps initialises native C++ libraries, and then
waits for the user's commands. If this is not required, terminate the script with
the \texttt{quit} command. This will cause Angort to exit with the return code 0.

\subsection{Words and functions}
\index{word}
Most of the Angort language consists of words which each perform
a single, isolated task -- there is very little syntax. Even common
``syntactic'' keywords like \texttt{if} (for conditions), \texttt{[]} 
(for creating lists) and \texttt{+} (for addition) operate primarily through
stack operations, although \texttt{if} does some more complex things at compile time
(such as calculating jump offsets). Code in Angort largely consists of many of these words
chained together to perform a task. These words can be combined into user-defined
functions.

In general, I will use ``word'' to refer to a single Angort built-in token,
particularily if it compiles to a single opcode; while ``function'' will refer
to user-defined functions. However, I may vary -- there is no real distinction, since
an Angort function call is itself a single opcode.
\clearpage
\subsection{Types and literals}
\label{types}
Angort is a dynamically typed language, with type coercion (weak typing).
The following types are available:
\indw{range}\indw{frange}\indw{[}\indw{]}
\begin{center}
\begin{tabular}{|l|p{2.5in}|l|p{1.5in}|}\hline
\textbf{Name\footnotemark[1]} & \textbf{Definition} & \textbf{Hashable\footnotemark[2]} & \textbf{Example of literal} \\ \hline
\texttt{none} & The nil object, specifying ``no value'' & N & \texttt{none} \\
\texttt{integer} & 32 or 64-bit integers depending on architecture & Y & \texttt{5045} \\
\texttt{long} & depends on architecture & Y & \texttt{5045l,32L,0ffx, 45ao, 10111b, 3200ffffhl} \\
\texttt{float} & 32-bit floats & Y & \texttt{54.0} \\
\texttt{double} & 64-bit floats & Y & \texttt{54.0l,32.2L} \\
\texttt{string} & Strings of characters & Y & \texttt{"Hello there"}\footnotemark[3] \\
\texttt{symbol} & Single-word strings, internally stored as integers and
generally used as hash keys & Y & \texttt{`foo} \\
\emph{Callable}\footnotemark[4] & Angort and C++ functions & N & \texttt{( dup * 1 + ),} \texttt{?myfunction} \\
\texttt{range} & 
A range of integers between two values with optional step & Y & 
\texttt{0 4 range}\footnotemark[5]\\
\texttt{frange} & A range of floats between two values with 
step& Y & \texttt{0 4 0.1 frange}\\
\texttt{list} & A array/list of values\footnotemark[6] & N & \texttt{[1,2,"foo"]} \\
\texttt{hash} & A map of values to values implemented as a hash table, where
keys can strings, symbols, integers or floats & N & \texttt{[\% `foo 1, "fish" "fish"]} \\
\hline
\end{tabular}
\end{center}
\footnotetext[1]{This is the name of the type as returned by the \texttt{type} word (see Sec.~\ref{typechecking}).}
\footnotetext[2]{Indicates that values of this type may be used as keys in a hash (see Sec.~\ref{hashes}).}
\footnotetext[3]{Multi-line strings can be defined using a ``heredoc''
similar to those in languages like bash, PHP and Python. See
Sec.~\ref{heredoc}.}
\footnotetext[4]{Actually conflates three types internally: \texttt{native} for C++ functions;
\texttt{codeblock}
for simple Angort functions; and \emph{closure}, whose values consist of a codeblock and
some stored variables. Check if a value is callable with \indw{iscallable}\texttt{iscallable}.}
\footnotetext[5]{This is actually a call to the \texttt{range} function which takes two integers to create a range.}
\footnotetext[6]{Stored internally as an
automatically resized array rather than a linked list.}

There are some other types used internally, such as the
types for iterators and deleted objects in a hash.

Integers can also have a base character, `b', `x'/`h', `o' or `d', which
goes before the optional 'l' for 'long.' \textbf{Note that} all numbers
must start with a digit, so a leading zero will be required for some 
hex numbers (e.g. `0ffh' not `ffh').

\subsection{Booleans}
Booleans in Angort are represented by integers -- zero is false, non-zero
is true. However, functions and words which nominally take a boolean value can
accept any type, which is converted to a boolean thus:
\begin{itemize}
\item integers are false if zero, true otherwise
\item ``none'' values are false
\item values of any other type are true
\end{itemize}
This avoids the need for such constructions as
\begin{lstlisting}
isnone not if "it exists!" then
\end{lstlisting}
\textbf{Note:} This feature arrived in version 3.1.0, and may not
be implemented fully in some plugin libraries. Use integers if in doubt.

\subsection{Heredoc strings}
Multi-line strings can be stacked 
using ``heredoc'' syntax. A heredoc block starts and ends with a marker,
which is a double hyphen followed by an identifier. Both markers
must be at the start of a line. Everything between
the markers, excluding the trailing newline character, will be put into
a single string on the stack. Here is an example:
\begin{lstlisting}
# the heredoc start marker. Markers must be on a line by themselves
# with no comment or trailing whitespace.
--FOO
This is a heredoc, which can contain quotes both 'single' and "double".
It can even contain apparent heredoc markers, which will be ignored
if they don't have the same identifier.
--FOO

# The string is on the stack, so print it.
.
\end{lstlisting}

\subsection{Retrieving value types}
\label{typechecking}
It is possible to retrieve the type of a value, or check that it is
one of a particular set of types, using the following words:
\indw{type}\indw{isnumber}\indw{isnone}\indw{iscallable}
\begin{center}
\begin{tabular}{|l|p{4in}|l|}\hline
\textbf{name} & \textbf{description} & \textbf{stack picture}\\ \hline
type & get name of value's type as a symbol & (val -- symbol)\\
isnumber & 1 if value's type is numeric, else 0 & (val -- int)\\
isnone & 1 if value's type is none, else 0 & (val -- int)\\
iscallable & 1 if value's type is codeblock, closure or native function, else 0 & (val -- int)\\
\hline
\end{tabular}
\end{center}

\clearpage
\section{Defining new functions}
New functions are defined with code of the form
\begin{v}
:functionname ... ;
\end{v}
A simple example is:
\begin{v}
:square dup *;
\end{v}
\indw{dup}
This will define a function \texttt{square} which will duplicate
the value on top of the stack, multiply the top two values
(effectively squaring the number\footnote{This will produce
an error if the value is not a number.}) and exit, leaving the
squared number on the stack. This can then be used thus:
\begin{v}
3 square 4 square + .
\end{v}
which will print 25, i.e. $3^2+4^2$. \index{return}\textbf{Note that leaving values behind
on the stack on exiting a function is how we return values in Angort.}
While defining a function, Angort is is compilation mode --- functions will
be converted to bytecode but added to the definition of the new function
rather than executed immediately. Function definitions can therefore span
more than one line:
\begin{lstlisting}
:factorial |x:|
    ?x 1 = if
        1
    else
        ?x ?x 1 - factorial *
    then
;  
\end{lstlisting}
This example uses variables, recursion and the Angort \texttt{if..else..then} construction.
This latter in particular looks a little odd to programmers not familiar with Forth -- please
see Section~\ref{conditions} for more details.


\subsection{Local variables and parameters}
\index{parameters}\index{variables!local}
Until now, most of the code has been perfectly valid Forth\footnote{With
the exception of the factorial function, which uses local variables
and recursion.}. However, the manipulation of
stack required in Forth is a challenge (and modern computers
have a little more memory), so Angort has a system of named
parameters and local variables. These can be defined by
putting a special block of the form
\begin{v}
|param1,param2,param3... : local1,local2,local3|
\end{v}
after the function name in the definition. Locals and parameters are
exactly the same internally, but the values of parameters are popped
off the stack when the new function is called. 

Once defined, locals (and parameters) can be read (i.e. pushed onto
the stack) using a question mark followed by the variable name.
Similarly, a local is written (i.e. a value popped off the stack and
stored in the local) by using an exclamation mark. For example,
\begin{lstlisting}
:pointless |x,y:z|
    ?x ?y + !z
;
\end{lstlisting}
will read the two arguments into the locals $x$ and $y$, add them,
store the result in the local $z$, and then exit, throwing everything away.
Note that a function with parameters but no locals is defined by leaving
the part after the colon empty:
\begin{lstlisting}
:magnitude |x,y:|
    ?x dup *
    ?y dup * +
    sqrt
;
\end{lstlisting}
while leaving the part before the colon empty will define a function with
locals but no parameters:
\begin{lstlisting}
:countToTen |:count|
    0!count
    {
        ?count 1+ dup !count
        dup .
        10 = ifleave
    }
;
\end{lstlisting}
Here, the curly brackets enclose a loop, which is exited by the
\texttt{ifleave} instruction when the stack top value is 10. See
Section~\ref{loops} for more details.

\subsection{Incrementing and decrementing}
\indw{"!+}\indw{"!-}
\index{increment}\index{decrement}\indw{inc}\indw{dec}
It is possible to increment and decrement the value on top of the stack
using the \texttt{inc} and \texttt{dec} words rather than using
the less efficient \texttt{1+} and \texttt{1-} sequences.
Additionally, rather than writing
\begin{lstlisting}
?var inc !var
\end{lstlisting}
we can use a special shorthand for incrementing a variable:
\begin{lstlisting}
!+var
\end{lstlisting}
As well as being more concise, it again produces more efficient code
(a single opcode rather than three). We can
also decrement:
\begin{lstlisting}
!-var
\end{lstlisting}
This works with both locals and globals.

\subsection{Parameter type checking}
\index{parameters!type checking}\index{type checking}
It is possible to specify the type required for each parameter by putting the type name
after the parameter name, separated by a slash `/' thus:
\begin{lstlisting}
:magnitude |x/float,y/float:|
    ?x dup *
    ?y dup * +
    sqrt
;
\end{lstlisting}
If the type of a parameter does not match, Angort will attempt to convert the 
value to the given type. If this fails, a type mismatch exception will be thrown.
Note that the attempted conversion can lead to some unexpected results. For example,
\begin{v}
"foo" 3 magnitude
\end{v}
will work, giving the result 3.0 . This is because the string ``foo'' will be converted
to a float value of zero. However,
\begin{v}
none 3 magnitude
\end{v}
will fail because \texttt{none} cannot be converted to any other type.
For stricter type checking, use the facilities described in
Sec.~\ref{typechecking}.

\subsection{Word documentation strings and stack pictures}
\label{stackpic}
Following the locals and parameters (or just the function name if there
are none) there may be a function documentation string. It has the form
\begin{v}
:"(before -- after) what the function does"
\end{v}
The section in brackets is known as a \emph{stack picture,}\footnote{Or sometimes
a \emph{stackflow symbol} -- the concept is borrowed from Forth and the literature
varies.} and describes
the action of the function on the stack. The part before the hyphen
shows the part of the stack removed by the function, with
the stack top to the right, and the part after
shows its replacement. For example:
\begin{lstlisting}
:dist |x1,y1,x2,y2:|
    :"(x1 y1 x2 y2 -- distance) calculate the distance between two points"
    ?x1 ?x2 - dup *     # this is (x1-x2)^2
    ?y1 ?y2 - dup *     # this is (y1-y2)^2
    + sqrt              # sum them, and find the root
;
\end{lstlisting}
Note that the names in the picture are not necessarily those of variables:
they are single word descriptions of values. Typically these will be variable
names for the ``before'' part, but not for the ``after'' part (since
the return values are simply what's left on the stack).

To print the documentation for a word, enter \texttt{??wordname} at
the prompt. This will also work for most built-in Angort functions,
but not all\footnote{This is because most Angort functions compile
to calls to C++ functions stored as ``native'' values,
which can have descriptions. Simpler operations,
such as \texttt{if..then..else}, loop markers, arithmetic and the ``.'' print operator, compile directly to bytecode opcodes.
These cannot have descriptions.}. It will also work for any functions
inside C++ plugin libraries (see Section~\ref{library}). For example:
\begin{v}
Angort version 2.9.2 (c) Jim Finnis 2012-2017
Use '??word' to get help on a word.
1|0 > ??redir
redir: (filename --) open a new file and redirect output to it.
 For more complex file output, use the IO library. On fail, throws
 ex$failed.
1|0 > 
\end{v}


\section{Basic built-in words}
\subsection{Stack manipulation}
\index{stack!manipulation}
There exist a number of words whose sole purpose is to manipulate
the stack. These words, and their stack pictures, are given in the table
below.
\indw{dup}\indw{drop}\indw{swap}\indw{over}
\begin{center}
\begin{tabular}{|l|p{4in}|}\hline
\textbf{name} & \textbf{stack picture}\\ \hline
dup & (a -- a a)\\
drop & (a --)\\
swap & (a b -- b a)\\
over & (a b -- a b a)\\
\hline
\end{tabular}
\end{center}
Note that this is a much smaller set than the set of Forth stack
words, which includes \texttt{rot}, \texttt{roll}, \texttt{nip} and \texttt{tuck}.
The local variable system makes such complex operations unnecessary.

\subsection{Binary operators}
\index{arithmetic!binary operators}
In the following operations
\begin{itemize}
\item Booleans are represented by integers: nonzero is true, zero is false.
\item If one of the operands is a string, the other will be converted to a string. Only ``+'', ``*''  and comparison operators will be valid.
\item If one of the operands is a long and the other is an integer, the integer will be converted to a long and the result will be a long.
\item If one of the operands is a float and the other is an integer or long, that will be converted to a float and the result will be a float.
\item If one of the operands is a double and the other is an integer, long, or float, that will will be converted to a double and the result will be a double.
\item The comparison operators will do identity checks on objects (lists, ranges etc.), not deep comparisons.
\item The comparison functions return booleans-as-integers, as described above.
\end{itemize}
\indw{and}\indw{or}
\indw{band}\indw{bor}\indw{bxor}
\begin{center}
\begin{tabular}{|l|l|p{4in}|}\hline
\textbf{name} & \textbf{stack picture} & \textbf{side-effects and notes}\\ \hline
+    & (a b -- a+b)&\\
-    & (a b -- a-b)&\\
$*$    & (a b -- a*b)& ints are coerced to floats if one operand is an int, but not otherwise. ``string int *'' produces
a repeated string, but ``int string *'' is invalid.\\
/    & (a b -- a/b)&\\
\%    & (a b -- a\%b) & integer remainder ("mod") operator\\
$>$    & (a b -- a$>$b)& string comparison works as expected, collections (lists and hashes) are invalid.\\
$<$    & (a b -- a$<$b)& string comparison works as expected, collections are invalid.\\
=    & (a b -- a=b)& string comparison checks for equality, not identity. Collection comparison (lists and hashes) test for identity only (i.e. true if the two operands are references to the same collection).\\
!=   & (a b -- a!=b)& see ``='' above.\\
and & (a b -- a$\wedge$b) & binary and -- inputs are coerced to integers, nonzero is true\\
or & (a b -- a$\vee$b) & binary or  -- inputs are coerced to integers, nonzero is true\\
band & (a b -- a \& b) & bitwise AND -- inputs coerced to long, output is long \\
bor & (a b -- a $|$ b) & bitwise OR -- inputs coerced to long, output is long \\
bxor & (a b -- a $\sim$ b) & bitwise XOR -- inputs coerced to long, output is long \\
\hline
\end{tabular}
\end{center}

\subsection{Unary operators}
\index{arithmetic!unary operators}
\indw{bnot}\indw{not}\indw{neg}\indw{abs}
\begin{center}
\begin{tabular}{|l|l|p{4in}|}\hline
\textbf{name} & \textbf{stack picture} & \textbf{side-effects and notes}\\ \hline
not & (a -- !a) & logical negation of a boolean (i.e. an integer)\\
neg & (a -- -a) & arithmetic negation of float or integer\\
abs & (a -- $|\textrm{a}|$) & absolute value\\
isnone & (a -- bool) & true if value is \texttt{none} \\
bnot & (a -- !b) & bitwise not --  input coerced to long, output is long \\
\hline
\end{tabular}
\end{center}

\subsection{Basic input and output}
\index{input/output!simple}
This section covers simple input and output over the standard IO streams.
for file IO, the \texttt{io} library is required. Output can be redirected
to a file with the \texttt{redir} word, however.

\subsubsection{Simple input}
\indw{read}
To read a line from standard input (i.e. the keyboard unless Angort
has been redirected) use \texttt{read}:
\begin{lstlisting}
(|:s|
    {
        read !s
        ?s "quit" = ifleave
        ?s toint dup* .
    }
)@ quit
\end{lstlisting}
This will convert each line to an integer and print its square,
unless ``quit'' is entered, which will terminate the program.
Note that \texttt{read} will not add the trailing newline character.

The construction used here -- putting the code inside \texttt{( ... )@} --
allows local variables and control structures which extend over more than one line to
be used outside a named function. It simply creates an anonymous
function (with the brackets) and runs it immediately (with the \texttt{@} 
symbol). This is dealt with in more detail in Section~\ref{multilineflow}.

\subsubsection{Simple output}
Three words cover most output situations:
\begin{itemize}
\indw{.}\item the ``dot'' word, written as ``.'', will pop the stack and print
the value followed by a newline. This is shown in many of the examples
above. The value is converted to a string for printing using a method
internal to the type.
\indw{p}\item The \texttt{p} word will do the same, but without the newline.
\indw{nl}\item The \texttt{nl} word will just print a newline.
\end{itemize}

\subsubsection{Output to stderr}
\index{input/output!to stderr}\indw{errp}\indw{errnl}
To output to the standard error stream, use the \texttt{errp} word
to print a value without the newline, and \texttt{errnl} to print just
a newline. There is no direct equivalent to ``.'', but this is achieved
with the sequence \texttt{errp errnl}.

\subsubsection{Output redirection}
\index{input/output!redirection}\indw{redir}\indw{endredir}
The \texttt{redir} word takes the name of a file. All subsequent output
using ``.'', \texttt{p} and \texttt{nl} will be redirected to this file.
The \texttt{endredir} word will end the redirection. Performing another
\texttt{redir} while a redirect is active will have the same result
as \texttt{endredir ``filename'' redir}. There is no notion of a
stack of file redirection.  

\subsubsection{Special output}
Several words exist for special output:
\begin{itemize}
\index{input/output!hexadecimal}\indw{x}\item \texttt{x} pops and prints a value as a hex integer.
\index{input/output!raw value}\indw{rawp}\item \texttt{rawp} pops and prints a value as a raw hex value. This will
be the underlying value stored in the value union. It is occasionally useful for debugging.
\end{itemize}
Neither of these words print a trailing newline.

\subsubsection{Formatted output}
\index{input/output!formatted}\indw{format}
A version of the C \texttt{printf} formatted print exists, under the
name \texttt{format}.
This takes a list of values (see Section~\ref{lists}) and a format string:
\begin{lstlisting}
[1,"hello"] "%20d: %s" format.
\end{lstlisting}
While it is not a full implementation, all but the more unusual formatting
options are supported.


\section{Global variables}
\indw{global}\index{variables!global}
Global variables are defined in two ways. The ``polite'' way is to use the 
\texttt{global} keyword, which creates a new global of the name following
it, initially holding the nil value \texttt{none}:
\begin{v}
1|0> global foo
1|0> ?foo.
NONE
1|0> 5!foo
1|0> ?foo.
5
\end{v}
The other way to define globals is simply to access a variable whose
name begins with a capital letter. If no global or local exists with that
name, a global is created with the initial \texttt{none} value:
\begin{v}
1|0> 5 !Foo
1|0> ?Foo.
5
\end{v}
Globals, unlike locals, do not require a \texttt{?} sigil to be read:
if the name is used ``bare'', their value will be stacked just as if the name
was preceded with \texttt{?}, unless they contain
an anonymous function. In this case, the function is run (see
Section~\ref{globdetails} below). It is, however, good practice to use
the sigil. Writing to a global is done using the familiar \texttt{!} sigil.

Finally, accessing a global using its name without a sigil
will do nothing if it contains None,
while accessing it with the \texttt{?} will stack the None:
\begin{v}
1|0 > 10!A
1|0 > ?A.
10
1|0 > A.
10
1|0 > none!A
1|0 > A.
  from [dot] <stdin>:5/2
Error: stack underflow in stack 'main'
Last line input: A.
1|0 > ?A.
NONE
1|0 > 
\end{v}


\section{Constants}
\indw{const}\index{constants}
Constants are similar to globals, but with the following differences:
\begin{itemize}
\item they are defined and set using the \texttt{const} keyword ---
this will pop a value off the stack and set the new constant to that value;
\item they can never be redefined or written to.
\end{itemize}
Here are some examples which might be found at the start of a maths
package:
\begin{lstlisting}
3.1415927 const pi
2.7182818 const e

180 pi/   const radsToDegsRatio
pi 180/   const degsToRadsRatio

:degs2rads
    :"(degs -- rads) convert degrees to radians"
    degsToRadsRatio*
;

:rads2degs
    :"(rads -- degs) convert radians to degrees"
    radsToDegsRatio*
;
\end{lstlisting}
