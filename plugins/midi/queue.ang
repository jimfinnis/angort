package queue
private

# our global list of queues
[] !Queues

# a list of any new queues to be added; adding to a list while
# we're iterating it can cause problems so we bolt these on after
# the main loop
[] !NewQueues

:processqueue |q,interval:item|
    :"(q time --) process a queue - takes the queue and the time since last processed"
    ?q?`nexttime ?interval - dup ?q!`nexttime
    0 < if
        # the next item has matured, run it
        ?q?`nextfunc @
        # when the list is not empty, get the next item
        ?q?`queue len 0 != if
            ?q?`queue shift !item
            0 ?item get ?q!`nexttime
            "Setting next item time to " ?q?`nexttime +.
            1 ?item get ?q!`nextfunc
        else
            # otherwise mark the list as dead
            -1 ?q!`nexttime 
            # and call the callback
            ?q?`cb @
        then
    then
;

public

# a queue consists of the queue itself, the next item in
# the queue, and how much time remains before that item
# is triggered. A queue item is a tuple of an anonymous function,
# typically a closure which plays a note or something; and
# the time after which it should run.

:mkqueue |list,callback:item|
    :"(list callback -- ) make a queue and add to system"
    
    # first we strip off the first item
    
    ?list shift !item
    
    [%
     `nexttime 0 ?item get,
     `nextfunc 1 ?item get,
     `queue ?list,
     `cb ?callback
     ]
    
    ?NewQueues push
;

:process |t:|
    :"(t --) process all queues, given a time interval"
    ?Queues each {
        i ?t processqueue
    }
    # now remove zombies
    ?Queues ( ?`nexttime 0 < not) filter
    # and append any new queues
    ?NewQueues len 0 != if
        ?NewQueues each{i,}
        [] !NewQueues
    then
    !Queues
;


