#!/usr/local/bin/angort

package mpcc

[`mpc,`id3,`io] each { i library drop}

none 0 mpc$connect

#number of songs to list in a listing

20 !ListWindow

private

# if a value is none, replace it with a string
:chknone |s:| ?s isnone
    if "<<NONE>>" else ?s then
;


# if a value is none, replace it with 0
:chknoneint |s:| ?s isnone
    if 0 else ?s then
;


# "decorate" a song hash, giving it a toString member.
:addstrconv |s:|
    (   |x:|
        ?x?`artist chknone
        ": " +
        ?x?`title chknone +
    ) ?s!`toString;

# wrap a string with quotes
:quote |x:| "\"" ?x "\"" ++;

# maximum of a list
:maxlist
    0 swap (over over < if swap then drop) reduce
;

:dosearch |tag,str:|
    :"(tag str -- list) non exact search shortcut"
    [% ?tag ?str] 0 mpc$search
    # add the toString tag
    dup each{i addstrconv};

# show a list of songs in the playlist
:showlist |startidx,endidx:list,titlen,artlen,stat,i|
    mpc$list !list
    mpc$stat !stat
    "List length: " std$p ?list len.
    
    # get the bit of the list we want
    ?startidx ?endidx ?startidx- 
    ?list slice !list
    
    # work out some max lengths
    
    ?list (?`artist chknone len) map maxlist  !artlen
    ?list (?`title chknone len) map maxlist  !titlen
    
    # adjust them to fit the screen
    
    {
        ?titlen ?artlen + 80 > if 
            ?titlen 20 > if ?titlen 1- !titlen then
            ?artlen 20 > if ?artlen 1- !artlen then
        else
            leave
        then
    }
    
    ?startidx !i
    ?list each {
        ?i ?stat?`pos = if
            ">> " std$p
        else
            "   " std$p
        then
        
        [?i, 
         i?`artist chknone ?artlen trunc ?artlen padleft,
         i?`title  chknone ?titlen trunc ?titlen padleft] 
        "%4d %s %s" format .
        ?i 1+ !i
    }
;

# get the track number from the MPD track number string e.g. "11/14" gives 11. 
:gettrack |x:|
    ?x?`track !x
    ?x isnone if
        0
    else
        ?x "/" stridx dup isnone if
            drop
            ?x toint
        else
            0 swap ?x slice toint
        then
    then
;

# sorting function to sort by album and then track number
:sortFunc |x,y:|
    ?x?`album chknone
    ?y?`album chknone
    cmp dup 0 = if
        drop
        ?x gettrack
        ?y gettrack cmp
    then
;

        
        
    
        
    



public

:getlist
    :"(-- list) get the current playlist"
    mpc$list dup each{i addstrconv};


:artist |name:|
    :"(name -- list) search for songs by an artist"
    `artist ?name dosearch;
    
:album |name:|
    :"(name -- list) search for songs on an album"
    `album ?name dosearch;

:song |name:|
    :"(name -- list) search for songs by title"
    `title ?name dosearch;

:grep |list,str:|
    :"(list str -- list) filter a list of songs for a string in the filename"
    ?list (?`name ?str istridx isnone not) filter;

:m
    :"(cmd --) run an mpc$mpc command and list the output"
    mpc$mpc each {i.};

global p # force a new definition in this namespace
:p
    :"(--) start playing"
    none mpc$play;
:s
    :"(--) stop playing"
    mpc$stop;

:ps
    :"(--) pause"
    mpc$pause;


    
global list # force a new definition in this namespace
:list |:stat,start,end|
    :"(n --) list the current playlist around the given song index"
    ?ListWindow 2/ -
    dup 0< if drop 0 then
    dup ?ListWindow +
    showlist;    


:l
    :"((n) --) list playlist. If stackct>1, show around that number, else show current"
    ct 0 = if
        mpc$stat ?`pos list
    else
        list
    then
;


:getn
    :"(n -- hash) get song N in the current list"
    getlist get;

:cur |:p|
    :"(-- hash) get current playing song"
    mpc$stat?`pos !p
    ?p 0 < not if
        ?p getlist get
    else
        none
    then
;

:stat |:stat,list|
    :"(--) show current status"
    mpc$stat !stat
    mpc$list !list # don't need to decorate with a toString member
    
    "State : " ?stat?`state +
    "  Volume : " ?stat?`volume + +.
    ?stat?`pos 0 < not if
        ?stat?`pos ?list get dup
        "Current Song: " std$p ?`title.
        "              " std$p ?`artist.
        ?stat?`elapsed "/" ?stat?`total + + .
    then
    
    
;

:clr :"(--) clear the playlist"
    mpc$clr;
:add :"(list --) add a list of songs to the  playlist"
    mpc$add;

:d |x:|
    :"(lst --) dump a list or hash"
    ?x type `hash = if
        ?x each {i std$p "   " std$p i ?x get .}
    else
        ?x each {i.}
    then;

:f 
    :"(--) move forwards in current playlist"
    mpc$next;

:b 
    :"(--) move backwards in current playlist"
    mpc$prev;

:g |x:|
    :"(n --) start playing from given song index in playlist"
    ?x mpc$play;

:shuf |lst:n,a,l|
    :"(list -- list) shuffle a list"
    ?lst len !l
    ?l 1- 0 range each {
        rand i % !a
        i ?lst get
        ?a ?lst get
        i ?lst set
        ?a ?lst set
    } ?lst;

:load
    :"(name --) load the playlist from a stored playlist"
    mpc$load;
:save 
    :"(name --) save the current playlist"
    mpc$save;

:rm
    :"(name --) delete a playlist"
    mpc$rm;

:ls
    :"(--) list all stored playlists"
    mpc$playlists each {i.};

:all |:ids|
    :"(--list) list all songs (takes ages)"
    []
    `artist [%] mpc$tags each {i.
        [% `artist i] 1 mpc$search each{i dup addstrconv, }
    }
;

    
:h
    :"(--) list all music player public words"
    "mpcc" listhelp
;

:getfn 
    :"(hash -- file) get full name (only works on local machine)"
    "/home/white/beetsmusic/" swap ?`name +
;

:loadtags
    :"(hash -- hash) read song tags into a hash"
    getfn id3$loadtags
;

:spp 20 padright;
:gfs |x,s:| # get from song
    ?s ?x?`songhash get chknone
;


:showprobs |:t|
    :"Scan for common errors in all ID3 tags - takes quite a while"
    
    all !t
    nl nl nl
    
    # first check, scan the files for weird null data
    ?t each {
        i?`artist isnone if "Null artist: " spp i?`name . then
        i?`title isnone if "Null title: " spp  i?`name . then
    }
    
    # below here won't work unless the data is local. It stores
    # the tag data in the song hash.
    [] ?t each {i loadtags i over !`songhash ,}
    
    each {
        i?`artist isnone if "Null artist: " spp i `name gfs +. then
        i?`title isnone if "Null title: " spp  i `name gfs +. then
    }
;


:srt
    :"(list -- list) sort list by album, then track"
    clone dup (mpcc$sortFunc) fsort
;

:lsrt
    :"(--) sort playlist by album, then track"
    mpc$list dup (mpcc$sortFunc) fsort clr add
;

:qqq |:f,len,ct|
    "Generate a list of all songs into alist (y/n)? " std$p
    
    0 1 none io$readstr slice
    dup "y" = swap "Y" = or if
        "alist" "w" io$open !f
        `artist [%] mpc$tags dup sort
        dup len !len
        0!ct
        each {
            ?ct tofloat ?len / 100 * toint "\r" + std$p none io$flush
            ?ct 1+ !ct
            
            i "\n" + ?f io$write
            0 i artist get?`name 48 trunc 50 padleft "\n"+ ?f io$write
        }
        0!f
    then
;

# stuff for checking file length / duration ratios.

:saveFileLengths |:f|
    # generate and save a hash of name to length
    "lengths" "w" io$open !f
    [%] all each {
        i i?`toString@
        i getfn io$stat?`size tofloat,
    }
    ?f io$write;
    

:listRatios |:f,lens,n|
    "lengths" "r" io$open io$readhash !lens
    [] all each {
        [%
         `name    i i?`toString@ dup!n,
         `ratio   i?`duration tofloat ?n ?lens get /
                  
         ],
    }
    dup (|x,y:| ?x?`ratio ?y?`ratio cmp) fsort
    "ratios" "w" io$open !f
    each {i?`name 50 trunc 50 padright i?`ratio + "\n"+ ?f io$write}
    0!f
;
endpackage import


