Function definitions should contain the closure map, which is just an array
of indices of parent locals. Compiling will now have locals, globals and 
closure variables. There will also be OP_CLOSUREGET and OP_CLOSURESET.

So. Compilation of variable:

    if there isn't a local of that name try to create a closure
    from the containing context into this block, and add it as a new
    closure variable. Recurse this so it goes all the way up. This means
    we'll have to be able to indicate in the closure map whether the variable
    comes from the parent's locals, or from its closures.
    
    OP_LITERALFUNC then uses the closure map to populate a new closure table
    which is stored with the IP as a Closure value.
    

    




1) Function definitions shouldn't consist of just IP, there
   needs to be a local/param block, and a closure map (which maps
   locals in the creating context to those in the current one.) That way
   we get rid of OP_LOCALS and provide better information.
   
2) Getting a local variable token:
    if there isn't a local of that name try to create a closure
    from the containing context into this block, and add it as a new
    local. Recurse this so it goes all the way up.

3) OP_LITERALFUNC should use the closure map to fetch data from
   current locals and store them into a closure data table which
   is stored with the IP, as a function value.

4) OP_CALL should handle vstack allocation and local popping, and
   also setting the values of some of those locals from the closure
   data table.


Function def = IP + closure map
Function value = function def + closure data table

========================
Further notes
* We need a locals table for each compile context


========================

:createadder |x|
    (|:a| ?x + ) ;   # ok, variable a is a bit pointless - it's an illustration
    
global adder
3 createadder !adder
4 ?adder call p

    
:createadder        enter compiling context    
|x|                 create new locals list in that context, with 1 parameter, x, with index 0
(                   push compiling context with no locals or params and an empty closure map
|:a|                create a single local called a in the new context
?x                  scan for x. It's not in the current context. Tell the current
                    context to scan its parent, and add a closure map entry if it finds one in
                    the parent. It finds one, and adds the closure map entry.
                    We create a new variable slot (1) and say this is bound to variable 0
                    in the parent.
)                   pop the context and compile the OP_LITERALCODE word:
                    Create a codeblock structure, containing both the IP and a closure map.
                    Write the closures to the closure map, here there's just one:
                    local variable 1 is bound to parent variable 0.
                    Output OP_LITERALCODE with (ip,closuremap): a codeblock

                    
3 createadder       stack 3 and call createadder.
                    OP_LOCALS will run, popping the 3 and binding it to the x slot (slot 0)
                    OP_LITERALCODE will run:
                        * the closure block says that local variable 1 is bound to parent var 0
                        * we allocate a new closure table 
                        * we get parent var 0
                        
Problematic allocations:
    the closure map - this is created when ")" is compiled. It should be OK, because we never
    forget code.
    
    the closure table - this is created when ")" is actually run, copying variables from the
    current context. It's stacked with the code's instruction pointer as a value, and exists
    for as long as that value exists. How the hell do we delete it? Oh, maybe it's OK - we don't
    have objects and references etc. so there can't be reference cycles, so all we need to do
    is make sure values delete old dynamically stored stuff when set, rather like the Lana ones.
    And we do that already!    
    
    Oh yes - you can't *write* to a closure. Or rather you can, but it's a different
    value now having been copied into a local. AFter all, the surrounding context is
    probably long dead.

so here we go.
    - local table now part of context
    - writing closure creation stuff (i.e. building the closure map during compile)
    


NEW CLOSURES

Data structures:
    Closure table:  gives the codeblock and index of closures used in
                    this function (indices into the closure block).
                    Made at compile time.

    Closure block:  array of values containing variables defined by this
                    function, which are used in child functions. Created
                    when the function value is instantiated???
                    
                    (this is iffy; consider a top-level function - can
                    there really be only one closure block? Each call
                    will need one.)
                    
                    This is reference counted and cycle detected.
                    
    Closure map:    This is a map of closure variable indices to
                    Value pointers, and is generated at create time(?)
                    
    

Closures are structured as above, with the following changes:

Compile time:
    If a local is not found, go up the tree until we find it. In
    that function, convert the local into a closure and modify the
    code, converting all references (OP_LOCAL*) into closures.
    Creating a closure is just a matter of increasing the closure count.

    Then add an entry to the closure table to both the new function
    and the function containing the variable. This consists of
    (CodeBlock *, int) tuples giving the owning codeblock and the
    closure index. The findOrCreateClosure() method called on the owning
    function (actually CompileContext) returns this tuple so it can be
    added to the child's closure table.
    
    This data always goes into CodeBlocks.
 
Create time:
    Creating an instance of a function is done when a define completes,
    or OP_LITERALCODE runs.

    Firstly, if the function requires a closure block (that is, it owns
    variables which were made into closures at compile time) one is created.
    The closure block is just an array of values, all None initially.
    
    Then the function's closure table is studied. For each entry, the return
    stack is scanned for the codeblock specified in the table, and a ..

Call time:

Return time:

De-ref time:   


